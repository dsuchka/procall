// SPDX-License-Identifier: BUSL-1.1
// Copyright (c) 2025 Evgenii Kozlov [dsuchka@gmail.com]
// Licensed under the Business Source License 1.1.

// Usage is permitted for non-commercial purposes only, under the terms of BUSL-1.1.
// Change Date: 2030-01-01
// On the Change Date, this license will automatically convert to GPL-3.0-or-later,
// granting full rights under the GNU General Public License.
//
// For more information, see https://github.com/mariadb/bsl
//                           https://opensource.org/licenses/BUSL-1.1
//                           https://spdx.org/licenses/BUSL-1.1.html
//                           https://www.hashicorp.com/en/bsl


#include "helper.huff"

#define function eval() payable returns()
#define function contract_name() view returns(string)
#define function contract_version() view returns(string)

#define macro CONSTRUCTOR() = takes(0) returns(0) {
    caller  SAVE_OWNER()
}

#define macro MAIN() = takes(0) returns(0) {
    // get selector (first 4 bytes) and check it against known functions
    // NOTE: use simple if-else cascade since the count of functions is not so great

    ZERO()  calldataload                // [<sel....>]
    0xE0    shr                         // [<sel>]

    // first check hot methods: "eval()"
    dup1 __FUNC_SIG(eval) eq handle_eval jumpi

    // then check empty call (when selector is empty, receive any value and return with no error)
    calldatasize                        // [<sz>, <sel>]
    other_selectors_check jumpi         // [<sel>]
    stop                                // receive any value and return with no error

    // otherwise check other methods
other_selectors_check:
    // Input stack:                     // [<sel>]
    dup1 __FUNC_SIG(contract_name) eq handle_contract_name jumpi
    dup1 __FUNC_SIG(contract_version) eq handle_contract_version jumpi

    // delegate to implementation (if any)
    LOAD_IMPLEMENTATION() dup1          // [<impl>, <impl>, <sel>]
    delegate_to_implementation jumpi    // [<impl>, <sel>]

    // do revert NoImplementation()
    __FUNC_SIG(NoImplementation)        // [<__no_impl_err_sel>, ...]
    do_revert_with_error_no_args jump

delegate_to_implementation:
    // Input stack:                     // [<impl>, ...]
    DOUBLE_ZERO()                       // [0, 0, <impl>, ...]
    calldatasize                        // [<sz>, 0, 0, <impl>, ...]
    ZERO()                              // [0, <sz>, 0, 0, <impl>, ...]
    calldatasize                        // [<sz>, 0, <sz>, 0, 0, <impl>, ...]
    DOUBLE_ZERO()                       // (0, 0, <sz>) [0, <sz>, 0, 0, <impl>, ...]
    calldatacopy                        // [0, <sz>, 0, 0, <impl>, ...]
                                        // | mem[0:<sz>] = [calldata]
    dup5                                // [<impl>, 0, <sz>, 0, 0, <impl>, ...]
    gas                                 // (<gas>, <impl>, 0, <sz>, 0, 0) [<impl>, ...]
    delegatecall                        // [<success>, <impl>, ...]
    ZERO()                              // [0, <success>, <impl>, ...]
    returndatasize                      // [<sz>, 0, <success>, <impl>, ...]
    returndatasize                      // [<sz>, <sz>, 0, <success>, <impl>, ...]
    DOUBLE_ZERO()                       // (0, 0, <sz>) [<sz>, 0, <success>, <impl>, ...]
    returndatacopy                      // [<sz>, 0, <success>, <impl>, ...]
    swap2                               // [<success>, 0, <sz>, <impl>, ...]
    return_with_return_data jumpi       // [0, <sz>, <impl>, ...]
    revert

return_with_return_data:
    return

//  method "contract_name()"
handle_contract_name:
    // Input stack:                     // [<sel>]
    PUSH_ARGS_FOR_RETURN_SHORT_MESSAGE(CONTRACT_NAME_STR, CONTRACT_NAME_LEN,
        do_return_short_message)


//  method "contract_version()"
handle_contract_version:
    // Input stack:                     // [<sel>]
    PUSH_ARGS_FOR_RETURN_SHORT_MESSAGE(CONTRACT_VERSION_STR, CONTRACT_VERSION_LEN,
        do_return_short_message)


do_revert_forbidden:
    __FUNC_SIG(Forbidden)
    // fall down to <do_revert_with_error_no_args>

do_revert_with_error_no_args:
    REVERT_ERROR_NO_ARGS()

do_return_short_message:
    RETURN_SHORT_MESSAGE()

//  method "eval()"
handle_eval:
    // Input stack:                     // [<sel>]
    CHECK_CALLER_IS_OWNER_OR_SELF(process_eval, do_revert_forbidden)

process_eval:
    //  Memory layout:
    //      0x0000              (???)               [1 word]
    //      0x0020              (???)               [1 word]
    //      0x0040              <reg_ptr>           [1 word]
    //      0x0060              <frame_state>       [1 word: 4 × uint64]
    //      0x0080..0x0280      opcodes jump table  [16 words]  (256 opcodes)
    //      0x0280..0x0300      extended jump table [4 words]   (64 opcodes)


    //  Frame state word consists of:
    //      [<mem_start> <mem_end> <depth> <code_start>]        (uint64 each)

    //  Previous frame descriptor consists of 2 words:
    //  #1. [<frame state>]
    //  #2. [<reg_ptr> <stack_ptr> <00..00> <code_end>]          (uint64 each)

    //  INVOKENEXT (deep invocation) mechanism:
    //
    //  Arguments on stack:  ... | [code bytes] [payload bytes] || <code_sz> <data_sz>
    //                             ^--code_sz-| ^-- data_sz --|    (pop 2 args)
    //                             ^--ret_ptr
    //
    //  Push frame data on stack and allocate new registers:
    //      ... | [code bytes] [payload bytes] || <prev_frame_desc> [registers] | =>
    //            ^--ret_ptr   ^-- mem_ptr        (0x20-aligned)    ^--reg_ptr    ^-- new SP and top
    //

    //  Main loop EVM-stack layout:
    //  dup<n>  value       desc        (explained desc)
    //  14      <OP>        opcode      (last readn opcode)
    //  13      0x80        const       0x80
    //  12      0x60        const       0x60
    //  11      0x40        const       0x40
    //  10      0x20        const       0x20
    //  9       0x01        const       0x01
    //  8       0x0F        const       (to trunc mod 2⁴ (4-bit value, 16 unique values))
    //  7       0x1F        const       (to trunc mod 2⁵ (5-bit value, 32 unique values))
    //  6       0xFF        const       (to trunc mod 2⁸ (8-bit value, a byte))
    //  5       0xFFFF      const       (to trunc mod 2¹⁶ (16-bit value, a jump location))
    //  4       <SP>        stack_ptr   (points to the beggining of the stack) [ActorVM-stack]
    //  3       <CE>        code_end    (points to the end of code)
    //  2       <TOP>       top_ptr     (points to the next free word on the stack) [require: SP <= TOP]
    //  1       <CP>        code_ptr    (points to the next opcode to be processed) [require: CP < CE]

    //  In one row notation:                        // [<CP>, <TOP>, <CE>, <SP>, const..., <OP>]

    ///////////////////////////////////////////////////////////////////////////////////////////////////////

    // push all the constants first
    0x80 0x60 0x40 0x20 0x01 0x0F 0x1F 0xFF 0xFFFF  // [const...]

    // load opcodes jump table into memory (0x0080..0x0280)
    // a magic number is: 0x00010001000100010001000100010001.0001000100010001.00010001.00010001
    // the magic number is used to multiply jump location address:
    //      jmp_loc * magic = jmp_loc x 16 times (packed)
    0x00010001 dup1                                 // <____0101>, <____0101>, const...]
    dup8 shl or dup1                                // <___0101>, <___0101>, const...]
    dup9 shl or dup1                                // <__0101>, <__0101>, const...]
    dup11 shl or                                    // <magic>, const...]

    // part.0: <debug_return_first_4k_bytes> x 1 time at the beginning (0x00)
    debug_return_first_4k_bytes dup2 mul            // [<jmp_debug_x16>, <magic>, const...]
    dup11                                           // [0x80, <jmp_unsup_x16>, <magic>, const...]
    mstore                                          // [<magic>, const...]

    // part.1: <process_eval_opcode_01_80_push_const> x 128 times (total 0x100 bytes [8 words])
    process_eval_opcode_01_80_push_const dup2 mul   // [<jmp01_80x16>, <magic>, ...]
    dup1 0x82 mstore    dup1 0xA2 mstore            // [<jmp01_80x16>, <magic>, ...]
    dup1 0xC2 mstore    dup1 0xE2 mstore            // [<jmp01_80x16>, <magic>, ...]
    dup1 0x102 mstore   dup1 0x122 mstore           // [<jmp01_80x16>, <magic>, ...]
    dup1 0x142 mstore        0x162 mstore           // [<magic>, ...]

    // part.1: <process_eval_opcode_81_9F_push_const> x 32' times (total 0x40 bytes [2 words])
    // NOTE: will write 1 byte more which will be rewritten later by [part.3]
    process_eval_opcode_81_9F_push_const dup2 mul   // [<jmp01_80x16>, <magic>, ...]
    dup1 0x182 mstore                               // [<jmp01_80x16>, <magic>, ...]
         0x1A2 mstore                               // [<magic>, ...]

    // part.3: <process_eval_opcode_A0_BF_push_data> x 32 times (total 0x40 bytes [2 words])
    process_eval_opcode_A0_BF_push_data mul         // [<jmpA0_BFx16>, const...]
    dup1 0x1C0 mstore                               // [<jmpA0_BFx16>, const...]
         0x1E0 mstore                               // [const...]

    // part.4: copy remaining locations from jump table
    dup9                                                // [0x80, const...]
    __tablestart(OPCODES__JUMP_TABLE) 0x200 codecopy    // [const...]

    // Frame:
    //  [system data] | [code] [regs] |
    //  (0x300 bytes) ^-- Frame       ^-- SP/top_ptr
    //

    // push code_ptr and save it at mem[0x60:0x80] (<frame_state>)
    0x0300                                  // [<CP>, const...]
    dup1 dup10 mstore                       // [<CP>, const...]
    // NOTE: frame state is packed 4 × uint64, the value is <code_ptr>
    //       (mem ptrs and depth are zero)

    // load code data (calldata after selector)
    0x04 dup1                               // [4, 4, <CP>, const...]
    calldatasize sub dup1                   // [<code_sz>, <code_sz>, 4, <CP>, const...]
    swap2                                   // [4, <code_sz>, <code_sz>, <CP>, const...]
    dup4                                    // (<CP>, 4, <code_sz>) [<code_sz>, <CP>, const...]
    calldatacopy                            // [<code_sz>, <CP>, const...]

    // evaluate code_end (<CE>)
    dup2 add                                // [<CE>, <CP>, const...]

    // evaluate reg_ptr (<RP>) [do word alignment: <CE+0x1F> & ~(0x1F)]
    dup5 dup2                               // [<CE>, 0x1F, <CE>, <CP>, const...]
    dup2 add                                // [<CE+0x1F>, 0x1F, <CE>, <CP>, const...]
    swap1 not                               // [<~0x1F>, <CE+0x1F>, <CE>, <CP>, const...]
    and                                     // [<RP>, <CE>, <CP>, const...]

    // store it: mem[0x40:0x60] = <reg_ptr>
    dup1                                    // [<RP>, <RP>, <CE>, <CP>, const...]
    dup11 mstore                            // [<RP>, <CE>, <CP>, const...]

    // evaluate stack_ptr (<SP>): reg_ptr + 0x400
    0x0400 add                              // [<SP>, <CE>, <CP>, const...]

    // evaluate top_ptr (starts from stack_ptr when stack is empty, i. e. TOP = SP)
    dup1                                    // [<SP>, <TOP>, <CE>, <CP>, const...]
    swap3                                   // [<CP>, <TOP>, <CE>, <SP>, const...]

    // begin evaluation main loop
    process_eval_main_loop jump

process_eval_handle_next_opcode:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, 0xFFFF, 0xFF, 0x1F, 0x0F, 0x01, 0x20, 0x40, ...]
    // advance code_ptr (<CP>): CP = CP+1
    dup1                                // [<CP>, | <CP>, <TOP>, <CE>, <SP>, const...]
    dup10 add                           // [<CP'>, | <CP>, <TOP>, <CE>, <SP>, const...]
    swap1                               // [<CP>, | <CP'>, <TOP>, <CE>, <SP>, const...]

    // NOTE: FROM HERE <CP'> (next CP) is normal <CP>

    // load next opcode and do jump
    // jump address is (mem[0x80+(opcode*2)-0x1E] => mem[0x62+(opcode*2)]) & 0xFFFF
    mload                               // [<dirtyOP>, | <CP>, <TOP>, <CE>, <SP>, 0xFFFF, 0xFF, 0x1F, 0x0F, const...]
    ZERO() byte                         // [<OP>, | <CP>, <TOP>, <CE>, <SP>, const...]
    dup1                                // [<OP>, <OP>, | <CP>, <TOP>, <CE>, <SP>, const...]
    swap15 pop                          // [<OP>, | <CP>, <TOP>, <CE>, <SP>, const..., <OP>]
    dup10                               // [1, <OP>, | <CP>, <TOP>, <CE>, <SP>, const...]
    shl                                 // [<OP*2>, | <CP>, <TOP>, <CE>, <SP>, const...]
    0x62 add                            // [<jmp_mem_addr>, | <CP>, <TOP>, <CE>, <SP>, const...]
    mload                               // [<dirty_jmp>, | <CP>, <TOP>, <CE>, <SP>, const...]
    dup6 and                            // [<jmp>, | <CP>, <TOP>, <CE>, <SP>, const...]
    jump                                // [<CP>, <TOP>, <CE>, <SP>, const...]


process_eval_opcode_F0_push_const:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    ZERO()                              // [<VALUE>, | ...]
    process_eval_push_value jump

process_eval_opcode_FF_push_const:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    ZERO() not                          // [<VALUE>, | ...]
    process_eval_push_value jump

process_eval_opcode_81_9F_push_const:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    // Formula: VALUE = 0x80 + (OP - 0x80)*0x20 = OP*0x20 - (0x20*0x80 - 0x80) = OP*0x20 - 0x0F80
    0x0F80                              // [0x0F80, | <CP>, <TOP>, <CE>, <SP>, const...]
    dup15                               // [<OP>, 0x0F80, | <CP>, <TOP>, <CE>, <SP>, const...]
    dup12 mul                           // [<OP*0x20>, 0x0F80, | ...]
    sub                                 // [<VALUE>, | ...]
    swap14 pop                          // [<CP>, <TOP>, <CE>, <SP>, const..., <VALUE>]
    // replace OP by the evaluated VALUE and
    // fall down to <process_eval_opcode_01_80_push_const>

process_eval_opcode_01_80_push_const:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const..., <OP>]
    dup14                               // [<OP>, | <CP>, <TOP>, <CE>, <SP>, const...]
    // fall down to <process_eval_push_value>

process_eval_push_value:
    // Input stack:                     // [<VALUE>, | <CP>, <TOP>, <CE>, <SP>, const...]
    dup3                                // [<TOP>, <VALUE>, | <CP>, <TOP>, <CE>, <SP>, const...]
    dup12 add                           // [<TOP'>, <VALUE>, | <CP>, <TOP>, <CE>, <SP>, const...]
    swap3                               // [<TOP>, <VALUE>, | <CP>, <TOP'>, <CE>, <SP>, const...]
    mstore                              // [<CP>, <TOP'>, <CE>, <SP>, const...]
    // fall down to <process_eval_main_loop>

process_eval_main_loop:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    CHECK_CODE_PTR_AND_HANDLE_NEXT(process_eval_handle_next_opcode)
    // fall down to <process_eval_return_stack_data>

process_eval_return_stack_data:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    dup4                                // [<SP>, | <CP>, <TOP>, <CE>, <SP>, const...]
    dup3                                // [<TOP>, <SP>, | <CP>, <TOP>, <CE>, <SP>, const...]
    sub                                 // [<sz>, | <CP>, <TOP>, <CE>, <SP>, const...]
    dup5                                // (<stack_ptr>, <sz>), [...]
    return

process_eval_recheck_ptrs:
    // Input stack:                     // [<SEU>, | <CP>, <TOP>, <CE>, <SP>, const...]
    dup3 sub                            // [<TOP'>, | <CP>, <TOP>, <CE>, <SP>, const...]
    dup1                                // [<TOP'>, <TOP'>, | <CP>, <TOP>, <CE>, <SP>, const...]
    dup6 sgt                            // [(SP > TOP'), <TOP'>, | <CP>, <TOP>, <CE>, <SP>, const...]
    process_eval_recheck_ptrs_revert_stack_underflow jumpi
                                        // [<TOP'>, | <CP>, <TOP>, <CE>, <SP>, const...]
    pop                                 // [<CP>, <TOP>, <CE>, <SP>, const...]
    process_eval_recheck_code_ptr jump  // [<CP>, <TOP>, <CE>, <SP>, const...]

process_eval_recheck_ptrs_revert_stack_underflow:
    // StackUnderflow(uint256 underflowSize) when [adj_top_ptr < stack_ptr] (TOP' < SP)
    // Input stack:                     // [<TOP'>, | <CP>, <TOP>, <CE>, <SP>, const...]
    dup5 sub                            // [<SP - TOP'>, | <CP>, <TOP>, <CE>, <SP>, const...]
    __FUNC_SIG(StackUnderflow)          // [<__error_selector>, <arg1>, | ...]
    // fall down to <do_revert_with_error_1_arg>

do_revert_with_error_1_arg:
    REVERT_ERROR_1_ARG()

process_eval_opcode_A0_BF_push_data:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    // NOTE: data_sz (in bytes) = <OP> - 0x9F
    0x9F dup15 sub                      // [<data_sz>, | <CP>, <TOP>, <CE>, <SP>, const...]

    // do copy next N (data_sz) bytes from code onto stack as a word
    dup2 dup2 add                       // [<CP'>, <data_sz>, | <CP>, <TOP>, <CE>, <SP>, const...]
    swap2                               // [<CP>, <data_sz>, | <CP'>, <TOP>, <CE>, <SP>, const...]
    mload                               // [<dirty_data>, <data_sz>, | ...]
    swap1                               // [<data_sz>, <dirty_data>, | ...]
    dup12 sub                           // [<0x20-data_sz>, <dirty_data>, | ...]
    0x03 shl                            // [<n_dirty_bits>, <dirty_data>, | ...]
    shr                                 // [<VALUE>, | <CP'>, <TOP>, <CE>, <SP>, const...]
    dup3                                // [<TOP>, <VALUE>, | <CP'>, <TOP>, <CE>, <SP>, const...]
    dup12 add                           // [<TOP'>, <VALUE>, | <CP'>, <TOP>, <CE>, <SP>, const...]
    swap3                               // [<TOP>, <VALUE>, | <CP'>, <TOP'>, <CE>, <SP>, const...]
    mstore                              // [<CP'>, <TOP'>, <CE>, <SP>, const...]
    // fall down to <process_eval_recheck_code_ptr>

process_eval_recheck_code_ptr:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    dup3 dup2 slt                       // [(CP < CE), | ...]
    process_eval_handle_next_opcode jumpi
    dup3 dup2 eq                        // [(CP == CE), | ...]
    process_eval_return_stack_data jumpi

    // OutOfCode(uint256 extraOffset) when (CP > CE)
    dup3 dup2 sub                       // [(CP - CE), | ...]
    __FUNC_SIG(OutOfCode)               // [<__error_selector>, <arg1>, | ...]
    do_revert_with_error_1_arg jump


process_eval_opcode_C0_add:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    EVAL_BINARY_OPCODE_DIRECT(add)
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_C1_sub:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    EVAL_BINARY_OPCODE_REVERSED(sub)
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_C2_mul:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    EVAL_BINARY_OPCODE_DIRECT(mul)
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_C3_div:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    EVAL_BINARY_OPCODE_REVERSED(div)
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_C4_sdiv:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    EVAL_BINARY_OPCODE_REVERSED(sdiv)
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_C5_mod:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    EVAL_BINARY_OPCODE_REVERSED(mod)
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_C6_smod:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    EVAL_BINARY_OPCODE_REVERSED(smod)
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_C7_exp:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    EVAL_BINARY_OPCODE_REVERSED(exp)
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_C8_neg:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    EVAL_UNARY_OPCODE_BEGIN()       // [<stack[0]>, <(top-1)_ptr>, | ...]
    ZERO() sub                          // [<VALUE>, <(top-1)_ptr>, | ...]
    EVAL_UNARY_OPCODE_END()             // [<CP>, <TOP>, <CE>, <SP>, const...]
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_C9_not:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    EVAL_UNARY_OPCODE(not)
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_CA_and:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    EVAL_BINARY_OPCODE_DIRECT(and)
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_CB_or:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    EVAL_BINARY_OPCODE_DIRECT(or)
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_CC_xor:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    EVAL_BINARY_OPCODE_DIRECT(xor)
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_CD_shl:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    EVAL_BINARY_OPCODE_DIRECT(shl)
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_CE_shr:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    EVAL_BINARY_OPCODE_DIRECT(shr)
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_CF_sar:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    EVAL_BINARY_OPCODE_DIRECT(sar)
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_D0_address:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    address                             // [<VALUE>, | ...]
    process_eval_push_value jump

process_eval_opcode_D1_caller:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    caller                              // [<VALUE>, | ...]
    process_eval_push_value jump

process_eval_opcode_D2_origin:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    origin                              // [<VALUE>, | ...]
    process_eval_push_value jump

process_eval_opcode_D3_callvalue:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    callvalue                           // [<VALUE>, | ...]
    process_eval_push_value jump

process_eval_opcode_D4_selfbalance:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    selfbalance                         // [<VALUE>, | ...]
    process_eval_push_value jump

process_eval_opcode_D5_timestamp:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    timestamp                           // [<VALUE>, | ...]
    process_eval_push_value jump

process_eval_opcode_D6_blocknumber:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    number                              // [<VALUE>, | ...]
    process_eval_push_value jump

process_eval_opcode_D7_gasleft:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    gas                                 // [<VALUE>, | ...]
    process_eval_push_value jump

process_eval_opcode_D8_balanceof:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    EVAL_UNARY_OPCODE(balance)
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_D9_pop:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    dup10 dup3 sub                      // [<(top-1)_ptr>, | <CP>, <TOP>, <CE>, <SP>, const...]
    // fall down to <process_eval_update_top_zero_seu>

process_eval_update_top_zero_seu:
    // Input stack:                     // [<TOP'>, | <CP>, <TOP>, <CE>, <SP>, const...]
    swap2 pop                           // [<CP>, <TOP'>, <CE>, <SP>, const...]
    CHECK_PTRS_ZERO_SEU_AND_HANDLE_NEXT(process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_E8_rload:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    EVAL_UNARY_OPCODE_BEGIN()           // [<stack[0]>, <(top-1)_ptr>, | ...]
    dup9 and                            // [<reg_idx>, <(top-1)_ptr>, | ...]
    dup12 mul                           // [<reg_idx*0x20>, <(top-1)_ptr>, | ...]
    dup13 mload                         // [<reg_ptr>, <reg_idx*0x20>, <(top-1)_ptr>, | ...]
    add                                 // [<reg_pos>, <(top-1)_ptr>, | ...]
    mload                               // [<VALUE>, <(top-1)_ptr>, | ...]
    EVAL_UNARY_OPCODE_END()             // [<CP>, <TOP>, <CE>, <SP>, const...]
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_E9_rsave:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    dup11 dup3 sub                      // [<(top-2)_ptr>, | <CP>, <TOP>, <CE>, <SP>, const...]
    swap2                               // [<TOP>, | <CP>, <(top-2)_ptr>, <CE>, <SP>, const...]
    dup3 mload                          // [<stack[-1]>, <TOP>, | <CP>, <(top-2)_ptr>, <CE>, <SP>, const...]
    swap1                               // [<TOP>, <stack[-1]>, | <CP>, <(top-2)_ptr>, <CE>, <SP>, const...]
    dup12 swap1 sub                     // [<(top-1)_ptr>, <stack[-1]>, | <CP>, <(top-2)_ptr>, <CE>, <SP>, const...]
    mload                               // [<stack[0]>, <stack[-1]>, | <CP>, <(top-2)_ptr>, <CE>, <SP>, const...]
    dup9 and                            // [<reg_idx>, <stack[-1]>, | <CP>, <(top-2)_ptr>, <CE>, <SP>, const...]
    dup12 mul                           // [<reg_idx*0x20>, <stack[-1]>, | <CP>, <(top-2)_ptr>, <CE>, <SP>, const...]
    dup13 mload                         // [<reg_ptr>, <reg_idx*0x20>, <stack[-1]>, | ...]
    add                                 // [<reg_pos>, <stack[-1]>, | ...]

    // NOTE: FROM HERE <(top-2)_ptr> is new TOP (<TOP'>)
    mstore                              // [<CP>, <TOP'>, <CE>, <SP>, const...]
    CHECK_PTRS_ZERO_SEU_AND_HANDLE_NEXT(process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_EE_rewind:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    dup10 dup3 sub                      // [<(top-1)_ptr>, | <CP>, <TOP>, <CE>, <SP>, const...]
    dup1 mload                          // [<n>, <(top-1)_ptr>, | <CP>, <TOP>, <CE>, <SP>, const...]
    swap1 sub                           // [<TOP'>, | <CP>, <TOP>, <CE>, <SP>, const...]
    process_eval_update_top_zero_seu jump

process_eval_opcode_F1_iszero:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    EVAL_UNARY_OPCODE(iszero)
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)

process_eval_opcode_F5_iif:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    dup11 dup3 sub                      // [<(top-2)_ptr>, | <CP>, <TOP>, <CE>, <SP>, const...]
    swap2                               // [<TOP>, | <CP>, <(top-2)_ptr>, <CE>, <SP>, const...]
    dup11 swap1 sub                     // [<(top-1)_ptr>, | <CP>, <(top-2)_ptr>, <CE>, <SP>, const...]
    mload iszero                        // [<!(stack[0])>, | <CP>, <(top-2)_ptr>, <CE>, <SP>, const...]
    process_eval_opcode_F5_iif_continue_unchanged jumpi

    // Input stack:                     // [<CP>, <(top-2)_ptr>, <CE>, <SP>, const...]
    dup2 mload                          // [<stack[-1]>, | <CP>, <(top-2)_ptr>, <CE>, <SP>, const...]
    dup11 dup4 sub                      // [<(top-3)_ptr>, <stack[-1]>, | <CP>, <TOP'>, <CE>, <SP>, const...]
    mstore                              // [<CP>, <TOP'>, <CE>, <SP>, const...]

process_eval_opcode_F5_iif_continue_unchanged:
    // Input stack:                     // [<CP>, <TOP'>, <CE>, <SP>, const...]
    CHECK_PTRS_AND_HANDLE_NEXT(dup10, process_eval_handle_next_opcode, process_eval_recheck_ptrs)


//
//  ** INVOCATION HANDLERS **
//

process_eval_opcode_FA_invoke_next:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    // AVM-Stack args:                  // [...] | [<code_sz> <data_sz>] |
    //                                  //          stack[-1] stack[0]
    //                                  //          ^-(top-2) ^-(top-1)  ^-(TOP)
    //                                  //          ^-(TOP')

    // re-copy consts (stack too deep) and make uint64 mask (U64M) (0xFFFF_FFFF_FFFF_FFFF)
    dup13 dup13 dup13 dup13 dup13       // [0x01, 0x20, 0x40, 0x60, 0x80, | <CP>, <TOP>, <CE>, <SP>, ...]
    dup1 dup4 shl                       // [(1 << 64), 0x01, 0x20, 0x40, 0x60, 0x80, | ...]
    sub                                 // [U64M, 0x20, 0x40, 0x60, 0x80, | <CP>, <TOP>, <CE>, <SP>, ...]

    // get <code_sz> and <data_sz> and evaluate new mem_start (payload data) and code_start
    dup2 dup8 sub                       // [<TOP-0x20>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]
    mload                               // [<data_sz>, U64M, 0x20, 0x40, 0x60, 0x80, | <CP>, <TOP>, <CE>, <SP>, ...]
    dup4 dup9 sub                       // [<TOP-0x40>, <data_sz>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]
    dup1 mload                          // [<code_sz>, <TOP'>, <data_sz>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]

    // eval nm_s (new mem_start) = TOP' - data_sz
    // NOTE: TOP' is nm_e (new mem_end)
    dup3 dup3 sub                       // [<nm_s>, <code_sz>, <TOP'>, <data_sz>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]
    swap3 pop                           // [<code_sz>, <TOP'>, <nm_s>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]

    // eval nc_s (new code_start) = nm_s - code_sz
    dup3 sub                            // [<nc_s>, <TOP'>, <nm_s>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]
    // NOTE: nc_e = nm_s: [code bytes] [payload bytes] ||
    //                    ^-nc_s       ^-(nc_e, nm_s)  ^-(nm_e, TOP')
                                        // [<nc_s>, <nm_e>, <nm_s>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]

    // evaluate previous frame descriptor ptr (PFD_ptr.1) = TOP'(nm_e) aligned 0x20
    dup15 dup1                          // [0x1F, 0x1F, <nc_s>, <nm_e>, <nm_s>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]
    dup4 add                            // [<nm_e+0x1F>, 0x1F, <nc_s>, <nm_e>, <nm_s>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]
    swap1 not and                       // [<PFD_ptr.1>, <nc_s>, <nm_e>, <nm_s>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]

    // Write previous frame descriptor (2 words):
    //  <state(old)> at PFD_ptr.1
    //  <RP.SP._.CE> at PFD_ptr.2 (= PFD_ptr.1 + 0x20)

    // load previous state (mem[0x60:0x80])
    dup8 mload                          // [<state>, <PFD_ptr.1>, <nc_s>, <nm_e>, <nm_s>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]
    // save previous state
    dup2 mstore                         // [<PFD_ptr.1>, <nc_s>, <nm_e>, <nm_s>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]
    // advance FDP_ptr (.1 => .2)
    dup6 add                            // [<PFD_ptr.2>, <nc_s>, <nm_e>, <nm_s>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]

    // form <RP.SP._.CE>
    dup7 mload                          // [<reg_ptr>, <PFD_ptr.2>, <nc_s>, <nm_e>, <nm_s>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]
    dup8 shl                            // [<RP._>, <PFD_ptr.2>, <nc_s>, <nm_e>, <nm_s>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]
    dup14 or                            // [<RP.SP>, <PFD_ptr.2>, <nc_s>, <nm_e>, <nm_s>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]
    dup10 shl                           // [<RP.SP._._>, <PFD_ptr.2>, <nc_s>, <nm_e>, <nm_s>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]
    dup13 or                            // [<RP.SP._.CE>, <PFD_ptr.2>, <nc_s>, <nm_e>, <nm_s>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]
    // save <RP.SP._.CE> at FDP.2
    dup2 mstore                         // [<PFD_ptr.2>, <nc_s>, <nm_e>, <nm_s>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]

    // advance FDP_ptr (.2 => new reg_ptr) and save it at mem[0x40:0x60] (actual reg_ptr location)
    dup6 add                            // [<new_RP>, <nc_s>, <nm_e>, <nm_s>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]
    dup1                                // [<new_RP>, <new_RP>, <nc_s>, <nm_e>, <nm_s>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]
    dup8 mstore                         // [<new_RP>, <nc_s>, <nm_e>, <nm_s>, U64M, 0x20, 0x40, 0x60, 0x80, | ...]
    // remember new_RP (push back) and pull U64M to the front
    swap4                               // [U64M, <nc_s>, <nm_e>, <nm_s>, <new_RP>, 0x20, 0x40, 0x60, 0x80, | ...]

    // Form and save new frame state: [<mem_start> <mem_end> <depth> <code_start>]

    // get current depth (from state at mem[0x60:0x80]) and increment it
    dup8 mload                          // [<x.x.depth.x>, U64M, <nc_s>, <nm_e>, <nm_s>, <new_RP>, 0x20, 0x40, 0x60, 0x80, | ...]
    dup8 shr                            // [<_.x.x.depth>, U64M, <nc_s>, <nm_e>, <nm_s>, <new_RP>, 0x20, 0x40, 0x60, 0x80, | ...]
    and                                 // [<depth>, <nc_s>, <nm_e>, <nm_s>, <new_RP>, 0x20, 0x40, 0x60, 0x80, | ...]
    // do increment depth: 0 - not(depth)
    not ZERO() sub                      // [<depth'>, <nc_s>, <nm_e>, <nm_s>, <new_RP>, 0x20, 0x40, 0x60, 0x80, | <CP>, ...]
    // update main loop var CP => nc_s
    dup2 swap10 pop                     // [<depth'>, <nc_s>, <nm_e>, <nm_s>, <new_RP>, 0x20, 0x40, 0x60, 0x80, | <CP'>, ...]
    // append new code start
    dup7 shl or                         // [<depth'.nc_s>, <nm_e>, <nm_s>, <new_RP>, 0x20, 0x40, 0x60, 0x80, | ...]

    // update main loop var: CE => nm_s (code_end = mem_start)
    dup3 swap11 pop                     // [<depth'.nc_s>, <nm_e>, <nm_s>, <new_RP>, 0x20, 0x40, 0x60, 0x80, | ...] (CE')

    // append new mem_start and mem_end
    swap2                               // [<nm_s>, <nm_e>, <depth'.nc_s>, <new_RP>, 0x20, 0x40, 0x60, 0x80, | ...]
    dup6 shl or                         // [<nm_s.nm_e>, <depth'.nc_s>, <new_RP>, 0x20, 0x40, 0x60, 0x80, | ...]
    dup7 shl or                         // [<nm_s.nm_e.depth'.nc_s>, <new_RP>, 0x20, 0x40, 0x60, 0x80, | ...]
    // save new frame state at mem[0x60:0x80]
    dup5 mstore                         // [<new_RP>, 0x20, 0x40, 0x60, 0x80, | <CP'>, <TOP>, <CE'>, <SP>, const...]

    // update main loop var SP => new reg_ptr + 0x400
    0x400 add                           // [<SP'>, 0x20, 0x40, 0x60, 0x80, | <CP'>, <TOP>, <CE'>, <SP>, const...]
    swap8 pop                           // [0x20, 0x40, 0x60, 0x80, | <CP'>, <TOP>, <CE'>, <SP'>, const...]

    // drop all temporary consts and make TOP = SP'
    pop pop pop pop                     // [<CP'>, <TOP>, <CE'>, <SP'>, const...]
    dup4 swap2 pop                      // [<CP'>, <TOP=SP'>, <CE'>, <SP'>, const...]

    // all done, go to the main loop handler
    process_eval_main_loop jump

//
//  ** SPECIAL HANDLERS **
//

process_eval_unsupported_code:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    dup14                               // [<OP>, | ...]
    __FUNC_SIG(UnsupportedCode)         // (<__error_selector>, <OP>), [...]
    do_revert_with_error_1_arg jump

debug_return_first_4k_bytes:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    0x1000 ZERO() return

debug_return_first_bytes_till_top:
    // Input stack:                     // [<CP>, <TOP>, <CE>, <SP>, const...]
    dup2 ZERO() return

}

#define jumptable__packed OPCODES__JUMP_TABLE {
//    debug_return_first_4k_bytes          // 0x00 is reserved, use 0xF0 to push zero
//                                         process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    // 32 opcodes
//
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    // 64 opcodes
//
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    // 96 opcodes
//
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const process_eval_opcode_01_80_push_const
//    // 128 opcodes (0x00..0x7F)
//
//    process_eval_opcode_01_80_push_const // 0x80 can be handled as is, same result, but less ops and cheaper
//                                         process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const
//    process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const
//    process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const
//    process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const
//    process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const
//    process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const
//    process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const
//    process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const process_eval_opcode_81_9F_push_const
//    // 32 opcodes (0x80..0x9F)  | total 160 opcodes
//
//    process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data
//    process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data
//    process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data
//    process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data
//    process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data
//    process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data
//    process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data
//    process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data process_eval_opcode_A0_BF_push_data
//    // 32 opcodes (0xA0..0xBF)  | total 192 opcodes
//
    process_eval_opcode_C0_add  process_eval_opcode_C1_sub  process_eval_opcode_C2_mul  process_eval_opcode_C3_div
    process_eval_opcode_C4_sdiv process_eval_opcode_C5_mod  process_eval_opcode_C6_smod process_eval_opcode_C7_exp
    process_eval_opcode_C8_neg  process_eval_opcode_C9_not  process_eval_opcode_CA_and  process_eval_opcode_CB_or
    process_eval_opcode_CC_xor  process_eval_opcode_CD_shl  process_eval_opcode_CE_shr  process_eval_opcode_CF_sar

    process_eval_opcode_D0_address          process_eval_opcode_D1_caller
    process_eval_opcode_D2_origin           process_eval_opcode_D3_callvalue
    process_eval_opcode_D4_selfbalance      process_eval_opcode_D5_timestamp
    process_eval_opcode_D6_blocknumber      process_eval_opcode_D7_gasleft
    process_eval_opcode_D8_balanceof

    process_eval_opcode_D9_pop
    process_eval_unsupported_code       // DA
    process_eval_unsupported_code       // DB
    process_eval_unsupported_code       // DC
    process_eval_unsupported_code       // DD
    process_eval_unsupported_code       // DE
    process_eval_unsupported_code       // DF

    process_eval_unsupported_code       // E0
    process_eval_unsupported_code       // E1
    process_eval_unsupported_code       // E2
    process_eval_unsupported_code       // E3
    process_eval_unsupported_code       // E4
    process_eval_unsupported_code       // E5
    process_eval_unsupported_code       // E6
    process_eval_unsupported_code       // E7
    process_eval_opcode_E8_rload
    process_eval_opcode_E9_rsave
    process_eval_unsupported_code       // EA
    process_eval_unsupported_code       // EB
    process_eval_unsupported_code       // EC
    process_eval_unsupported_code       // ED
    process_eval_opcode_EE_rewind
    process_eval_unsupported_code       // EF

    process_eval_opcode_F0_push_const
    process_eval_opcode_F1_iszero
    process_eval_unsupported_code       // F2
    process_eval_unsupported_code       // F3
    process_eval_unsupported_code       // F4
    process_eval_opcode_F5_iif
    process_eval_unsupported_code       // F6
    process_eval_unsupported_code       // F7
    process_eval_unsupported_code       // F8
    process_eval_unsupported_code       // F9
    process_eval_opcode_FA_invoke_next
    process_eval_unsupported_code       // FB
    process_eval_unsupported_code       // FC
    debug_return_first_bytes_till_top   // FD
    process_eval_unsupported_code       // FE
    process_eval_opcode_FF_push_const

}

